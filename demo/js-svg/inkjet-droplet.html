<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Inkjet Meniscus Control (Demo) - Left→Right</title>
<style>
  :root{ --bg:#020617; --fg:#e5e7eb; --line:#334155; --noz:#64748b; }
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    display:flex; flex-direction:column; align-items:center; gap:10px; padding:16px;
  }
  h1{margin:0; font-size:14px; font-weight:600; opacity:.95}
  .panel{
    width:min(980px, 96vw);
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    border:1px solid var(--line); border-radius:10px; padding:10px;
  }
  label{display:flex; gap:8px; align-items:center; font-size:12px}
  input[type="range"]{width:180px}
  button{
    background:transparent; color:var(--fg);
    border:1px solid var(--line); border-radius:10px;
    padding:6px 10px; cursor:pointer;
  }
  button:hover{border-color:#64748b}
  svg{
    width:min(980px, 96vw); height:auto;
    background:var(--bg);
    border:1px solid var(--line);
    border-radius:14px;
    display:block;
  }
  .hint{width:min(980px,96vw); font-size:12px; opacity:.85; line-height:1.5}
</style>
</head>
<body>
  <h1>Inkjet Meniscus Control (Demo) — flight:+X / gravity:+X / “必ず当たる”モード</h1>

  <div class="panel">
    <label>g(+X)
      <input id="g" type="range" min="0" max="0.18" step="0.005" value="0.07">
      <span id="gV"></span>
    </label>
    <label>air drag
      <input id="drag" type="range" min="0" max="0.06" step="0.002" value="0.012">
      <span id="dragV"></span>
    </label>
    <label>drive gain
      <input id="gain" type="range" min="0.4" max="2.2" step="0.05" value="1.35">
      <span id="gainV"></span>
    </label>
    <label>cycle
      <input id="cycle" type="range" min="180" max="420" step="10" value="260">
      <span id="cycleV"></span>
    </label>
    <button id="resetBtn">reset</button>
    <button id="pauseBtn">pause</button>
  </div>

  <div class="hint">
    ・デモ優先：空気抵抗は軽め、かつ <b>substrate に近づくと加速補助</b>（安全弁）で必ず着弾します。<br>
    ・「drive gain」を上げると押し波が強くなり、液柱・初速が増えてそれっぽく見えます。
  </div>

  <svg id="svg" viewBox="0 0 980 420" aria-label="inkjet demo">
    <defs>
      <radialGradient id="inkGrad" cx="35%" cy="30%" r="85%">
        <stop offset="0%" stop-color="#bae6fd"/>
        <stop offset="55%" stop-color="#38bdf8"/>
        <stop offset="100%" stop-color="#0284c7"/>
      </radialGradient>

      <filter id="glow">
        <feGaussianBlur stdDeviation="2.3" result="b"/>
        <feMerge>
          <feMergeNode in="b"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>

      <linearGradient id="metal" x1="0" x2="1">
        <stop offset="0" stop-color="#6b7280"/>
        <stop offset="0.5" stop-color="#94a3b8"/>
        <stop offset="1" stop-color="#64748b"/>
      </linearGradient>

      <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#0b1220" stroke-width="1"/>
      </pattern>
    </defs>

    <rect x="0" y="0" width="980" height="420" fill="url(#grid)"/>

    <!-- substrate -->
    <g id="substrateG">
      <rect id="substrate" x="740" y="40" width="48" height="340" rx="10" fill="#0b1220" stroke="#1f2937" />
      <text x="764" y="28" text-anchor="middle" font-size="12" fill="#94a3b8">substrate</text>
    </g>

    <!-- nozzle block -->
    <g id="nozzleG">
      <rect x="40" y="150" width="80" height="120" rx="10" fill="url(#metal)" opacity="0.98"/>
      <rect x="120" y="205" width="12" height="10" rx="2" fill="#475569"/>
      <rect x="116" y="198" width="8" height="24" rx="3" fill="#1f2937" opacity="0.55"/>
    </g>

    <!-- meniscus -->
    <path id="meniscus" fill="url(#inkGrad)" filter="url(#glow)" d=""/>

    <!-- jet -->
    <path id="jet" fill="url(#inkGrad)" filter="url(#glow)" d=""/>

    <!-- droplets -->
    <g id="drops"></g>

    <!-- splats -->
    <g id="splats"></g>

    <text x="150" y="28" font-size="12" fill="#94a3b8">flight:+X / gravity:+X</text>
  </svg>

<script>
(() => {
  // =========================
  // Params (demo-tuned)
  // =========================
  const P = {
    nozzleX: 132, nozzleY: 210,
    menH: 22,
    neck0: 14, neckMin: 2.2,

    // motion
    g: 0.07,         // +X gravity
    drag: 0.012,     // light drag
    gain: 1.35,      // drive gain

    // visuals / timing
    cycle: 260,      // frames until reset
    substrateX: 740, // closer for demo
    impactEps: 3,

    // "必ず当たる" safety assist
    assistZone: 180,    // start assist when within this distance
    assistMinV: 3.6,    // ensure at least this vx near substrate
    assistA: 0.06,      // extra accel (demo-only)

    // satellites
    satProb: 0.85,
    mergeDist: 10.0,
  };

  // =========================
  // DOM
  // =========================
  const meniscus = document.getElementById("meniscus");
  const jet = document.getElementById("jet");
  const dropsG = document.getElementById("drops");
  const splatsG = document.getElementById("splats");
  const substrateRect = document.getElementById("substrate");

  const $ = (id)=>document.getElementById(id);
  const gS=$("g"), dragS=$("drag"), gainS=$("gain"), cycleS=$("cycle");
  const gV=$("gV"), dragV=$("dragV"), gainV=$("gainV"), cycleV=$("cycleV");
  const resetBtn=$("resetBtn"), pauseBtn=$("pauseBtn");

  function bind(sl, out, key, fmt=3){
    const upd=()=>{ P[key]=Number(sl.value); out.textContent=Number(sl.value).toFixed(fmt); };
    sl.addEventListener("input", upd); upd();
  }
  bind(gS, gV, "g", 3);
  bind(dragS, dragV, "drag", 3);
  bind(gainS, gainV, "gain", 3);
  bind(cycleS, cycleV, "cycle", 0);

  // keep substrate in sync if you change later
  function syncSubstrate(){
    substrateRect.setAttribute("x", P.substrateX);
  }
  syncSubstrate();

  // =========================
  // Helpers
  // =========================
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  let seed=1234567;
  const rand=()=>((seed=(seed*1664525+1013904223)>>>0) / 4294967296);

  function meniscusPath(x, amp){
    const h=P.menH;
    const y0=P.nozzleY-h, y1=P.nozzleY+h;
    // surface thickness for “liquid edge”
    return `
      M ${x} ${y0}
      Q ${x+amp} ${P.nozzleY} ${x} ${y1}
      L ${x+2} ${y1}
      Q ${x+amp+2} ${P.nozzleY} ${x+2} ${y0}
      Z
    `;
  }

  function jetPath(x0, len, neck){
    const x1=x0+len;
    const yT=P.nozzleY-neck, yB=P.nozzleY+neck;

    // mild curvature that increases with length
    const k1 = clamp(22 + len*0.08, 22, 60);
    const k2 = clamp(18 + len*0.06, 18, 55);

    return `
      M ${x0} ${yT}
      C ${x0+k1} ${yT-5}, ${x1-k2} ${yT-6}, ${x1} ${yT}
      L ${x1} ${yB}
      C ${x1-k2} ${yB+6}, ${x0+k1} ${yB+5}, ${x0} ${yB}
      Z
    `;
  }

  function makeEl(tag){
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
  }

  function makeDrop(kind){
    const el = makeEl(kind==="main" ? "ellipse" : "circle");
    el.setAttribute("fill","url(#inkGrad)");
    el.setAttribute("filter","url(#glow)");
    el.setAttribute("opacity","0");
    dropsG.appendChild(el);
    return el;
  }

  function addSplat(x,y,scale=1){
    const g = makeEl("g");
    const e = makeEl("ellipse");
    e.setAttribute("cx",x); e.setAttribute("cy",y);
    e.setAttribute("rx", 3*scale); e.setAttribute("ry", 2.2*scale);
    e.setAttribute("fill","url(#inkGrad)");
    e.setAttribute("opacity","0.9");
    g.appendChild(e);

    // micro splash dots
    for(let i=0;i<7;i++){
      const c = makeEl("circle");
      const ang = (i/7)*Math.PI*2 + rand()*0.5;
      const r = 7*scale + rand()*10*scale;
      c.setAttribute("cx", x + Math.cos(ang)*r);
      c.setAttribute("cy", y + Math.sin(ang)*r);
      c.setAttribute("r", 0.7*scale + rand()*1.7*scale);
      c.setAttribute("fill","url(#inkGrad)");
      c.setAttribute("opacity","0.7");
      g.appendChild(c);
    }

    splatsG.appendChild(g);
    return { g, e, life:0, scale };
  }

  // =========================
  // Drive waveform (looks right)
  // pull -> push -> ring
  // =========================
  function drive(t){
    if(t < 14) return -0.65 * Math.sin(Math.PI * t/14);
    if(t < 34) return  1.40 * Math.sin(Math.PI * (t-14)/20);
    const u = (t-34);
    return Math.exp(-u/26) * Math.sin(u/4.1);
  }

  // =========================
  // State
  // =========================
  let running = true;
  let t = 0;

  let menX = P.nozzleX;
  let menV = 0;

  let jetLen = 0;
  let neck = P.neck0;

  let pinched = false;
  let pinchT = 0;

  const main = { el: makeDrop("main"), alive:false, x:0,y:0, vx:0,vy:0, rx:18,ry:16, mass:1.0 };
  const s1   = { el: makeDrop("sat"),  alive:false, x:0,y:0, vx:0,vy:0, r:4.2, mass:0.25 };
  const s2   = { el: makeDrop("sat"),  alive:false, x:0,y:0, vx:0,vy:0, r:3.4, mass:0.18 };

  const splats = [];

  function reset(){
    t = 0;
    menX = P.nozzleX;
    menV = 0;
    jetLen = 0;
    neck = P.neck0;
    pinched = false;
    pinchT = 0;

    for(const d of [main,s1,s2]){
      d.alive=false;
      d.el.setAttribute("opacity","0");
    }

    // clear splats
    while(splatsG.firstChild) splatsG.removeChild(splatsG.firstChild);
    splats.length = 0;

    // clear jet to avoid trailing
    jet.setAttribute("d","");
  }

  resetBtn.addEventListener("click", reset);
  pauseBtn.addEventListener("click", ()=>{
    running = !running;
    pauseBtn.textContent = running ? "pause" : "resume";
    if(running) requestAnimationFrame(step);
  });

  // =========================
  // Merge (sat -> main)
  // =========================
  function tryMerge(trailer, leader){
    if(!trailer.alive || !leader.alive) return;
    const dx = leader.x - trailer.x;
    const dy = leader.y - trailer.y;
    const dist = Math.hypot(dx,dy);

    const behind = trailer.x < leader.x;
    const faster = trailer.vx > leader.vx;

    if(behind && faster && dist < P.mergeDist){
      const m = trailer.mass + leader.mass;
      leader.vx = (leader.vx*leader.mass + trailer.vx*trailer.mass)/m;
      leader.vy = (leader.vy*leader.mass + trailer.vy*trailer.mass)/m;
      leader.mass = m;

      if(leader === main){
        const s = Math.cbrt(leader.mass);
        leader.rx = 18*s;
        leader.ry = 16*s;
      }
      trailer.alive=false;
      trailer.el.setAttribute("opacity","0");
    }
  }

  // =========================
  // Impact
  // =========================
  function impact(d){
    d.alive=false;
    d.el.setAttribute("opacity","0");
    const y = clamp(d.y, 55, 365);
    const scale = (d===main) ? clamp(Math.cbrt(d.mass), 0.8, 1.6) : 0.75;
    splats.push(addSplat(P.substrateX, y, scale));
  }

  function render(d){
    if(!d.alive) return;
    if(d===main){
      d.el.setAttribute("cx", d.x);
      d.el.setAttribute("cy", d.y);
      d.el.setAttribute("rx", d.rx);
      d.el.setAttribute("ry", d.ry);
    }else{
      d.el.setAttribute("cx", d.x);
      d.el.setAttribute("cy", d.y);
      d.el.setAttribute("r", d.r);
    }
    d.el.setAttribute("opacity","1");
  }

  // =========================
  // Pinch event
  // =========================
  function pinch(){
    pinched = true;
    pinchT = t;

    const tipX = menX + jetLen + 18;

    // main drop (stronger initial speed so it "goes")
    main.alive = true;
    main.mass  = 1.0;
    main.x = tipX;
    main.y = P.nozzleY;

    const pushNow = Math.max(0, drive(t))*P.gain;

    main.vx = clamp(4.2 + menV*0.9 + pushNow*2.2, 3.2, 12.0);
    main.vy = (rand()-0.5) * 0.7;

    main.rx = 18; main.ry = 16;
    main.el.setAttribute("opacity","1");

    // satellites (looks-right)
    const wantSat = rand() < P.satProb;
    if(wantSat){
      s1.alive=true;
      s1.x = tipX - (26 + rand()*16);
      s1.y = P.nozzleY - (7 + rand()*7);
      s1.vx = main.vx * (0.72 + rand()*0.10);
      s1.vy = (rand()-0.5) * 1.0;
      s1.mass=0.24;
      s1.r = 4.0;
      s1.el.setAttribute("opacity","1");

      s2.alive=true;
      s2.x = tipX - (48 + rand()*22);
      s2.y = P.nozzleY + (6 + rand()*8);
      s2.vx = main.vx * (0.58 + rand()*0.10);
      s2.vy = (rand()-0.5) * 1.0;
      s2.mass=0.18;
      s2.r = 3.2;
      s2.el.setAttribute("opacity","1");
    }else{
      s1.alive=false; s2.alive=false;
      s1.el.setAttribute("opacity","0");
      s2.el.setAttribute("opacity","0");
    }
  }

  // =========================
  // Main loop
  // =========================
  function step(){
    if(!running) return;

    t += 1;

    // --- meniscus control
    const u = drive(t) * P.gain;

    // meniscus motion (toy acoustic)
    menV += u * 0.20;
    menV *= 0.90;
    menX += menV;

    // meniscus bulge (visual)
    const amp = clamp(u*13, -18, 24);
    meniscus.setAttribute("d", meniscusPath(menX, amp));

    // --- jet extend/neck
    const push = Math.max(0, u);
    const pull = Math.max(0, -u);

    // extend on push, retract on pull
    jetLen += (2.2*push + 0.6*Math.max(0,menV)) - (1.0*pull);
    jetLen = clamp(jetLen, 0, 560);

    // necking: shrink with length, slight recovery with pull
    neck += (-0.10*jetLen/28) + (0.12*pull);

    // capillary-like ripple (visual only)
    neck += 0.30 * Math.exp(-(t-18)/90) * Math.sin((t-18)/3.5);
    neck = clamp(neck, P.neckMin, P.neck0);

    // draw jet
    if(!pinched){
      jet.setAttribute("d", jetPath(menX, jetLen, neck));
    }else{
      // small ligament after pinch (shrinks away)
      const lt = (t - pinchT);
      const shortLen = clamp(44 - lt*0.55, 0, 44);
      if(shortLen > 0){
        jet.setAttribute("d", jetPath(menX, shortLen, clamp(neck+1.0, P.neckMin, P.neck0)));
      }else{
        jet.setAttribute("d", "");
      }
    }

    // pinch condition (demo tuned)
    if(!pinched && t > 42 && jetLen > 120 && neck < 3.0){
      pinch();
    }

    // --- droplet physics (+X gravity, light drag)
    for(const d of [main,s1,s2]){
      if(!d.alive) continue;

      // base dynamics
      d.vx += (P.g - P.drag*d.vx);
      d.vy += (-0.06*d.vy);

      // "必ず当たる" assist near substrate (demo-only)
      const dist = (P.substrateX - d.x);
      if(dist < P.assistZone){
        if(d.vx < P.assistMinV) d.vx += P.assistA;  // ensure progress
        // small “attraction” to centerline (looks neat)
        d.vy += (P.nozzleY - d.y) * 0.0008;
      }

      d.x += d.vx;
      d.y += d.vy;

      // main droplet oscillation (visual)
      if(d === main){
        const tau = Math.max(0, t - pinchT);
        const osc = Math.exp(-tau/42) * Math.sin(tau/3.9);
        const s = Math.cbrt(d.mass);
        d.rx = 18*s + osc*2.8;
        d.ry = 16*s - osc*2.8;
      }
    }

    // merge satellites into main
    tryMerge(s1, main);
    tryMerge(s2, main);

    // impact check
    for(const d of [main,s1,s2]){
      if(!d.alive) continue;
      if(d.x >= (P.substrateX - P.impactEps)){
        impact(d);
      }
    }

    // render droplets
    render(main); render(s1); render(s2);

    // animate splats
    for(const sp of splats){
      sp.life += 1;
      const grow = 1 + Math.min(2.6, sp.life/10);
      const fade = Math.max(0, 1 - sp.life/90);
      sp.e.setAttribute("rx", 3.0*sp.scale*grow);
      sp.e.setAttribute("ry", 2.2*sp.scale*grow);
      sp.e.setAttribute("opacity", 0.85*fade);
      if(sp.life > 140 && sp.g.parentNode){
        sp.g.parentNode.removeChild(sp.g);
      }
    }

    // cycle reset
    if(t > P.cycle){
      reset();
    }

    requestAnimationFrame(step);
  }

  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
